{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pydanclick","text":"<p>Use Pydantic models as Click options.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Install:</p> <pre><code>pip install pydanclick\n</code></pre> <p>Let's assume you have a Pydantic model:</p> <pre><code>class TrainingConfig(BaseModel):\n    epochs: int\n    lr: Annotated[float, Field(gt=0)] = 1e-4\n    early_stopping: bool = False\n</code></pre> <p>Add all its fields as options in your Click command:</p> <pre><code>from pydanclick import from_pydantic\n\n@click.command()\n@from_pydantic(TrainingConfig)\ndef cli(training_config: TrainingConfig):\n    # Here, we receive an already validated Pydantic object.\n    click.echo(training_config.model_dump_json(indent=2))\n</code></pre> <pre><code>~ python my_app.py --help\nUsage: my_app.py [OPTIONS]\n\nOptions:\n  --early-stopping / --no-early-stopping\n  --lr FLOAT RANGE                [x&gt;0]\n  --epochs INTEGER                [required]\n  --help                          Show this message and exit.\n</code></pre> <p>Keep reading:</p> <ul> <li>Take a tour of the Features below</li> <li>Read the Examples</li> <li>See the API Reference</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#use-native-click-types","title":"Use native Click types","text":"<p>The following types are converted to native Click types:</p> Pydantic type Converted to <code>bool</code> <code>click.BOOL</code> <code>str</code> <code>click.STRING</code> <code>int</code> <code>click.INT</code> <code>float</code> <code>click.FLOAT</code> <code>Annotated[int, Field(lt=..., ge=...)</code> <code>click.IntRange()</code> <code>Annotated[float, Field(lt=..., ge=...)</code> <code>click.FloatRange()</code> <code>pathlib.Path</code> <code>click.Path()</code> <code>uuid.UUID</code> <code>click.UUID</code> <code>datetime.datetime</code>, <code>datetime.date</code> <code>click.DateTime()</code> <code>Literal</code> <code>click.Choice</code> <p>Complex container types such as lists or dicts are also supported: they must be passed as JSON strings, and will be validated through Pydantic <code>TypeAdapter.validate_json</code> method:</p> <pre><code>--arg1 '[1, 2, 3]' --arg2 '{\"a\": bool, \"b\": false}'\n</code></pre> <p>In any case, Pydantic validation will run during model instantiation.</p>"},{"location":"#add-multiple-models","title":"Add multiple models","text":"<p><code>pydanclick.from_pydantic</code> can be called several times with different models.</p> <p>Use the <code>prefix</code> parameter to namespace the options from different models:</p> <pre><code>class Foo(BaseModel):\n    a: str = \"\"\n    b: str = \"\"\n\nclass Bar(BaseModel):\n    x: int = 0\n    y: int = 0\n\n@click.command()\n@from_pydantic(Foo, prefix=\"foo\")\n@from_pydantic(Bar, prefix=\"bar\")\ndef cli(foo: Foo, bar: Bar):\n    pass\n</code></pre> <p>will give:</p> <pre><code>~ python cli.py\nUsage: cli.py [OPTIONS]\n\nOptions:\n  --foo-a TEXT\n  --foo-b TEXT\n  --bar-x INTEGER\n  --bar-y INTEGER\n  --help           Show this message and exit.\n</code></pre>"},{"location":"#add-regular-options-and-arguments","title":"Add regular options and arguments","text":"<p><code>pydanclick</code> can be used alongside regular options and arguments:</p> <pre><code>@click.command()\n@click.argument(\"arg\")\n@click.option(\"--option\")\n@from_pydantic(Foo)\ndef cli(arg, option, foo: Foo):\n    pass\n</code></pre> <p>will give:</p> <pre><code>~ python cli.py\nUsage: cli.py [OPTIONS] ARG\n\nOptions:\n  --option TEXT\n  --a TEXT\n  --b TEXT\n  --help         Show this message and exit.\n</code></pre> <p>Specify a custom variable name for the instantiated model with the same syntax as a regular Click option:</p> <pre><code>@click.command()\n@from_pydantic(\"some_name\", Foo)\ndef cli(some_name: Foo):\n    pass\n</code></pre>"},{"location":"#document-options","title":"Document options","text":"<p>Options added with <code>pydanclick.from_pydantic</code> will appear in the command help page.</p> <p>From docstrings: if <code>griffe</code> is installed, model docstring will be parsed and the Attributes section will be used to document options automatically (you can use <code>pip install pydanclick[griffe]</code> to install it). Use <code>docstring_tyle</code> to choose between <code>google</code>, <code>numpy</code> and <code>sphinx</code> coding style. Disable docstring parsing by passing <code>parse_docstring=False</code>.</p> <p>From field description: <code>pydanclick</code> supports the <code>Field(description=...)</code> syntax from Pydantic. If specified, it will take precedence over the docstring description.</p> <p>Explicitly: you can always specify a custom help string for a given field by using <code>extra_options={\"my_field\": {\"help\": \"my help string\"}}</code> where <code>my_field</code> is the name of your field.</p> <p>Here are these three methods in action:</p> <pre><code>class Baz(BaseModel):\n    \"\"\"Some demo model.\n\n    Attributes:\n        a: this comes from the docstring (requires griffe)\n    \"\"\"\n\n    a: int = 0\n    b: Annotated[int, Field(description=\"this comes from the field description\")] = 0\n    c: int = 0\n\n\n@click.command()\n@from_pydantic(Baz, extra_options={\"c\": {\"help\": \"this comes from the `extra_options`\"}})\ndef cli(baz: Baz):\n    pass\n</code></pre> <p>will give:</p> <pre><code>~ python cli.py --help\nUsage: cli.py [OPTIONS]\n\nOptions:\n  --a INTEGER  this comes from the docstring (requires griffe)\n  --b INTEGER  this comes from the field description\n  --c INTEGER  this comes from the `extra_options`\n  --help       Show this message and exit.\n</code></pre>"},{"location":"#customize-option-names","title":"Customize option names","text":"<p>Specify option names with <code>rename</code> and short option names with <code>shorten</code>:</p> <pre><code>@click.command()\n@from_pydantic(Foo, rename={\"a\": \"--alpha\", \"b\": \"--beta\"}, shorten={\"a\": \"-A\", \"b\": \"-B\"})\ndef cli(foo: Foo):\n    pass\n</code></pre> <p>will give:</p> <pre><code>~ python cli.py --help\nUsage: cli.py [OPTIONS]\n\nOptions:\n  -A, --alpha TEXT\n  -B, --beta TEXT\n  --help            Show this message and exit.\n</code></pre> <p>Note that <code>prefix</code> won't be prepended to option names passed with <code>rename</code> or <code>shorten</code>.</p>"},{"location":"#pass-extra-parameters","title":"Pass extra parameters","text":"<p>Use <code>extra_options</code> to pass extra parameters to <code>click.option</code> for a given field.</p> <p>For example, in the following code, the user will be prompted for the value of <code>a</code>:</p> <pre><code>@click.command()\n@from_pydantic(Foo, extra_options={\"a\": {\"prompt\": True}})\ndef cli(foo: Foo):\n    pass\n</code></pre>"},{"location":"#add-nested-models","title":"Add nested models","text":"<p>Nested Pydantic models are supported, with arbitrary nesting level. Option names will be built by joining all parent names and the field names itself with dashes.</p> <pre><code>class Left(BaseModel):\n    x: int\n\nclass Right(BaseModel):\n    x: int\n\nclass Root(BaseModel):\n    left: Left\n    right: Right\n    x: int\n\n@click.command()\n@from_pydantic(Root)\ndef cli(root: Root):\n    pass\n</code></pre> <p>will give:</p> <pre><code>~ python cli.py --help\nUsage: cli.py [OPTIONS]\n\nOptions:\n  --left-x INTEGER   [required]\n  --right-x INTEGER  [required]\n  --x INTEGER        [required]\n  --help             Show this message and exit.\n</code></pre> <p>To use <code>rename</code>, <code>shorten</code>, <code>exclude</code>, <code>extra_options</code> with a nested field, use its dotted name, e.g. <code>left.x</code> or <code>right.x</code>. Note that the alias of a field will apply to all its sub-fields:</p> <pre><code>@click.command()\n@from_pydantic(Root, rename={\"right\": \"--the-other-left\"})\ndef cli(root: Root):\n    pass\n</code></pre> <p>will give:</p> <pre><code>~ python cli.py --help\nUsage: cli.py [OPTIONS]\n\nOptions:\n  --left-x INTEGER            [required]\n  --the-other-left-x INTEGER  [required]\n  --x INTEGER                 [required]\n  --help                      Show this message and exit.\n</code></pre>"},{"location":"#unpacking-experimental","title":"Unpacking (experimental)","text":"<p>Unpacking provides a simpler API when working with list of submodels.</p> <p>Consider the following example:</p> <pre><code>class Author:\n    name: str\n    primary: bool = False\n\n\nclass Book:\n    title: str\n    authors: list[Author]\n\n@click.command()\n@from_pydantic(Book, unpack_list=True)\ndef cli(book: Book):\n    pass\n</code></pre> <p>By default, this would create two command-line arguments <code>--title</code> and <code>--authors</code>. Since <code>authors</code> has a complex type, it should be passed as a JSON string (e.g. <code>--authors '[{\"authors\": {\"name\": \"Alice\", \"primary\": true}, {\"name\": \"Bob\"}]'). Using</code>unpacked_list<code>will instead \"unpack\" the nested field</code>name<code>into the main namespace: this new argument is called</code>--authors-name` and can be specified multiple time, for example:</p> <pre><code>python cli.py --authors-name Alice --authors-primary --authors-name Bob\n</code></pre> <p>would create:</p> <pre><code>Book(authors=[Author(name=\"Alice\", primary=True), Author(name=\"Bob\")])\n</code></pre> <p>Note that you must always specify objects with optional arguments before objects without them. For example, the following command would make <code>Bob</code> the primary author, not <code>Alice</code>:</p> <pre><code>python cli.py --authors-name Bob --authors-name Alice --authors-primary\n</code></pre> <p>(Why? Because under the hood, arguments are collected per field <code>{\"name\": [Bob, Alice], \"primary\": [True]}</code>, and relative placement between fields cannot be accessed.)</p> <p>When in doubt, you can simply specify all arguments:</p> <pre><code>python cli.py --authors-name Bob --no-authors-primary --authors-name Alice --authors-primary\n</code></pre> <p>This API is experimental and will not work in complex cases (deeply nested lists, lists of union, and much more). See issue #20 for context and details.</p>"},{"location":"#limitations","title":"Limitations","text":"<p><code>pydanclick</code> doesn't support (yet!):</p> <ul> <li>Pydantic v1</li> <li>converting fields to arguments, instead of options</li> <li>fields annotated with union of Pydantic models can only be used with JSON inputs, instead of properly merging all sub-fields</li> <li>custom argument validators</li> </ul> <p>Other missing features:</p> <ul> <li>Reading model from file</li> <li>Specifying all field-specific options directly in the Pydantic model (would allow easier reuse)</li> <li>Most Click features should be supported out-of-the-box through the <code>extra_options</code> parameter. However, most of them aren't tested</li> <li>Click and Pydantic both include validation logic. In particular, Click support custom <code>ParamType</code>, validation callbacks and <code>BadParameter</code> errors: it's not clear if we want to fully rely on Pydantic or on Click or on a mixture of both</li> <li>populating Pydantic fields from existing options or arguments (combined with <code>exclude</code>, it will provide a complete escape hatch to bypass Pydantclick when needed)</li> <li>attaching Pydanclick arguments directly to the model class, to avoid duplication when re-using a model in multiple commands</li> </ul>"},{"location":"api_reference/","title":"API Reference","text":"<p>options: show_root_heading: false show_root_members_full_path: true show_root_full_path: true</p>"},{"location":"api_reference/#pydanclick.from_pydantic","title":"from_pydantic","text":"<pre><code>from_pydantic(\n    __var_or_model: Union[str, type[BaseModel]],\n    model: Optional[type[BaseModel]] = None,\n    *,\n    exclude: Sequence[str] = (),\n    rename: Optional[dict[str, str]] = None,\n    shorten: Optional[dict[str, str]] = None,\n    prefix: Optional[str] = None,\n    parse_docstring: bool = True,\n    docstring_style: Literal[\n        \"google\", \"numpy\", \"sphinx\"\n    ] = \"google\",\n    extra_options: Optional[\n        dict[str, _ParameterKwargs]\n    ] = None,\n    ignore_unsupported: Optional[bool] = False,\n    unpack_list: bool = False\n) -&gt; Callable[[Callable[..., T]], Callable[..., T]]\n</code></pre> <p>Decorator to add fields from a Pydantic model as options to a Click command.</p> <p>Parameters:</p> Name Type Description Default <code>__var_or_model</code> <code>Union[str, type[BaseModel]]</code> <p>name of the variable that will receive the Pydantic model in the decorated function</p> required <code>model</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic model</p> <code>None</code> <code>exclude</code> <code>Sequence[str]</code> <p>field names that won't be added to the command</p> <code>()</code> <code>rename</code> <code>Optional[dict[str, str]]</code> <p>a mapping from field names to command line option names (this will override any prefix). Option names must start with two dashes</p> <code>None</code> <code>shorten</code> <code>Optional[dict[str, str]]</code> <p>a mapping from field names to short command line option names. Option names must start with one dash</p> <code>None</code> <code>prefix</code> <code>Optional[str]</code> <p>a prefix to add to option names (without any dash)</p> <code>None</code> <code>parse_docstring</code> <code>bool</code> <p>if True and <code>griffe</code> is installed, parse the docstring of the Pydantic model and pass argument documentation to the Click <code>help</code> option</p> <code>True</code> <code>docstring_style</code> <code>Literal['google', 'numpy', 'sphinx']</code> <p>style of the docstring (<code>google</code>, <code>numpy</code> or <code>sphinx</code>). Ignored if <code>parse_docstring</code> is False</p> <code>'google'</code> <code>extra_options</code> <code>Optional[dict[str, _ParameterKwargs]]</code> <p>a mapping from field names to a dictionary of options passed to the <code>click.option()</code> function</p> <code>None</code> <code>ignore_unsupported</code> <code>Optional[bool]</code> <p>ignore unsupported model fields instead of raising</p> <code>False</code> <code>unpack_list</code> <code>bool</code> <p>if True, a list of nested models (e.g. <code>list[Foo]</code>) will be yield one command-line option for each field in the nested model. Each field can be specified multiple times. This API is experimental.</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., T]], Callable[..., T]]</code> <p>a decorator that adds options to a function</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Install the environment and the pre-commit hooks with</p> <pre><code>make install\n</code></pre> <p>Run tests with:</p> <pre><code>pytest\n</code></pre> <p>Serve the documentation locally with:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"examples/complex/","title":"Example: Multiple Models","text":"<p>In this second example, we use multiple models in a single command:</p> <pre><code>from pathlib import Path\nfrom typing import Annotated, Literal, Optional\n\nimport click\nfrom pydantic import BaseModel, Field\n\nfrom pydanclick import from_pydantic\n\n\nclass TrainingConfig(BaseModel):\n    \"\"\"Simple training config.\n\n    Attributes:\n    \"\"\"\n\n    epochs: int\n    batch_size: int = 64\n    log_file: Optional[Path] = None\n\n\nclass OptimizerConfig(BaseModel):\n    optimizer: Literal[\"sgd\", \"adam\", \"adamw\", \"adagrad\"] = \"adam\"\n    learning_rate: Annotated[float, Field(gt=0)] = 1e-2\n    decay_steps: Annotated[int, Field(description=\"Attach a description directly in the field\")] = 2_000\n    decay_rate: Annotated[float, Field(gt=0, lt=1)] = 1e-4\n\n\nclass LossConfig(BaseModel):\n    \"\"\"Loss configuration.\n\n    Attributes:\n        func: loss function\n        from_logits: if True, interpret `y` as logits\n    \"\"\"\n\n    func: Literal[\"cross_entropy\", \"mse\", \"hinge\"] = \"cross_entropy\"\n    from_logits: bool = True\n\n\nclass Config(BaseModel):\n    verbose: bool\n    training: TrainingConfig\n    optimizer: OptimizerConfig\n    loss: LossConfig\n\n\n@click.command()\n@click.option(\"--verbose/--no-verbose\", default=False, help=\"Verbose output\")\n@from_pydantic(TrainingConfig, extra_options={\"batch_size\": {\"default\": 12}})\n@from_pydantic(\n    OptimizerConfig,\n    prefix=\"opt\",\n    rename={\"optimizer\": \"--opt\"},\n    shorten={\"learning_rate\": \"--lr\", \"optimizer\": \"-o\"},\n    exclude=[\"decay_rate\"],\n)\n@from_pydantic(\n    LossConfig,\n    prefix=\"loss\",\n    rename={\"func\": \"--loss\"},\n    shorten={\"func\": \"-l\"},\n    parse_docstring=False,\n)\ndef cli(\n    verbose: bool,\n    training_config: TrainingConfig,\n    optimizer_config: OptimizerConfig,\n    loss_config: LossConfig,\n):\n    \"\"\"A slightly more complex examples with multiple models and various options.\"\"\"\n    config = Config(verbose=verbose, training=training_config, optimizer=optimizer_config, loss=loss_config)\n    click.echo(config.model_dump_json(indent=2))\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <pre><code>~ python examples/complex.py --help\nUsage: complex.py [OPTIONS]\n\n  A slightly more complex examples with multiple models and various options.\n\nOptions:\n  --verbose / --no-verbose        Verbose output\n  --epochs INTEGER                [required]\n  --batch-size INTEGER\n  --log-file PATH\n  -o, --opt [sgd|adam|adamw|adagrad]\n  --opt-learning-rate, --lr FLOAT RANGE\n                                  [x&gt;0]\n  --opt-decay-steps INTEGER       Attach a description directly in the field\n  -l, --loss [cross_entropy|mse|hinge]\n  --loss-from-logits / --no-loss-from-logits\n  --help                          Show this message and exit.\n</code></pre> <p>You can notice that:</p> <ul> <li><code>prefix</code> can be use to have different namespaces for different models</li> <li>fields can be excluded with <code>exclude</code></li> <li>regular options can be used alongside <code>pydanclick</code></li> <li>option names can be controlled with <code>rename</code> and `shorten</li> <li>docstring parsing can be disabled with <code>parse_docstring=False</code></li> </ul>"},{"location":"examples/complex_types/","title":"Example: Complex Types","text":"<p>Complex container types such as lists or dicts are supported: they must be passed as JSON strings, and will be parsed by Pydantic through the <code>TypeAdapter.validate_json</code> method. Consider the following Pydantic model:</p> <pre><code>from pathlib import Path\nfrom typing import Literal\n\nimport click\nfrom pydantic import BaseModel, Field\n\nfrom pydanclick import from_pydantic\n\n\nclass RunConfig(BaseModel):\n    \"\"\"Configure how to run your container.\n\n    Attributes:\n        image: image name\n        mounts: how to mount data on your container, as triples `(mount_type, src, dst)`\n        ports: port binding\n    \"\"\"\n\n    image: str\n    mounts: list[tuple[Literal[\"bind\", \"volume\", \"tmpfs\"], Path, Path]] = Field(default_factory=list)\n    ports: dict[int, int] = Field(default_factory=dict)\n\n\n@click.command()\n@from_pydantic(\"config\", RunConfig)\ndef cli(config: RunConfig):\n    \"\"\"A fake Docker client.\"\"\"\n    # Here, we receive an already validated Pydantic object.\n    click.echo(config.model_dump_json(indent=2))\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>It can be ran with:</p> <pre><code>python examples/complex_types.py \\\n    --image foo \\\n    --mounts '[[\"tmpfs\", \"/foo/bar\", \"foo/\"], [\"bind\", \".\", \"foo/\"]]' \\\n    --ports '{\"80\":80, \"8888\":8888}'\n</code></pre> <p>Pay attention to single quotes versus double quotes: quotes are required around the JSON strings to prevent shell extension, and JSON strings must use double quotes.</p> <p>Such types as marked as <code>JSON STRING</code> in the Click documentation:</p> <pre><code>~ python examples/complex_types.py --help                                                                                                                        &lt;aws:tooling&gt;\nUsage: complex_types.py [OPTIONS]\n\n  A fake Docker client.\n\nOptions:\n  --image TEXT          image name  [required]\n  --mounts JSON STRING  how to mount data on your container, as triples\n                        `(mount_type, src, dst)`\n  --ports JSON STRING   port binding\n  --help                Show this message and exit.\n</code></pre> <p>As of now, Pydanclick doesn't provide a mechanism to override this.</p>"},{"location":"examples/nested/","title":"Nested Example","text":"<p>In this third example, our Pydantic model itself contains Pydantic models. Nested fields can be overridden from the command-line:</p> <pre><code>from typing import Literal\n\nimport click\nfrom pydantic import BaseModel, Field\n\nfrom pydanclick import from_pydantic\n\n\nclass Foo(BaseModel):\n    \"\"\"Foo.\n\n    Attributes:\n        a: first letter\n        b: second letter\n    \"\"\"\n\n    a: int = 1\n    b: bool = True\n\n\nclass Baz(BaseModel):\n    \"\"\"Baz.\n\n    Attributes:\n        c: third letter\n    \"\"\"\n\n    c: Literal[\"a\", \"b\"] = \"a\"\n\n\nclass Bar(BaseModel):\n    \"\"\"Bar.\n\n    Attributes:\n        a: an argument\n        b: another one\n        baz: a third one\n    \"\"\"\n\n    a: float = 0.1\n    b: str = \"b\"\n    baz: Baz = Field(default_factory=Baz)\n\n\nclass Obj(BaseModel):\n    \"\"\"Obj.\n\n    Attributes:\n        foo: foo attribute\n        bar: bar attribute\n    \"\"\"\n\n    foo: Foo = Field(default_factory=Foo)\n    bar: Bar = Field(default_factory=Bar)\n\n\n@click.command()\n@from_pydantic(\"obj\", Obj, rename={\"bar.baz\": \"baz\"})\ndef cli(obj: Obj):\n    click.echo(obj.model_dump_json(indent=2))\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <pre><code>~ python examples/nested.py --help                                                                                                                               &lt;aws:tooling&gt;\nUsage: nested.py [OPTIONS]\n\nOptions:\n  --foo-a INTEGER       first letter\n  --foo-b / --no-foo-b  second letter\n  --bar-a FLOAT         an argument\n  --bar-b TEXT          another one\n  --baz-c [a|b]         third letter\n  --help                Show this message and exit.\n</code></pre> <p>Some observations:</p> <ul> <li>you can <code>rename</code> any field by using its dotted name (here, <code>bar.baz</code>)</li> <li>same notation can be used for <code>exclude</code>, <code>shorten</code>, <code>extra_options</code></li> <li>when a field is renamed, all its subfields are renamed, too</li> </ul>"},{"location":"examples/simple/","title":"Simple Example","text":"<p>In this first example, we use a single model and default values:</p> <pre><code>from typing import Annotated\n\nimport click\nfrom pydantic import BaseModel, Field\n\nfrom pydanclick import from_pydantic\n\n\nclass TrainingConfig(BaseModel):\n    \"\"\"Simple training config.\n\n    Attributes:\n        epochs: number of epochs\n        lr: learning rate\n        early_stopping: whether to stop training when validation loss stops decreasing\n    \"\"\"\n\n    epochs: int\n    lr: Annotated[float, Field(gt=0)] = 1e-4\n    early_stopping: bool = False\n\n\n@click.command()\n@from_pydantic(TrainingConfig)\ndef cli(training_config: TrainingConfig):\n    \"\"\"A simple example with a few parameters and default behavior.\"\"\"\n    # Here, we receive an already validated Pydantic object.\n    click.echo(training_config.model_dump_json(indent=2))\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <pre><code>python examples/simple.py --help\nUsage: simple.py [OPTIONS]\n\n  A simple example with a few parameters and default behavior.\n\nOptions:\n  --epochs INTEGER                number of epochs  [required]\n  --lr FLOAT RANGE                learning rate  [x&gt;0]\n  --early-stopping / --no-early-stopping\n                                  whether to stop training when validation\n                                  loss stops decreasing\n  --help                          Show this message and exit.\n</code></pre> <p>You can notice that:</p> <ul> <li>fields without default values are marked as <code>required</code></li> <li>constraints are properly recognized by Click</li> <li>boolean fields are converted to boolean flags, as recommended by Click</li> </ul>"}]}